use core {array}
use core.intrinsics.types {type_is_struct}

split :: (string: str, delimiter: u8) -> [] str {

    tokens: [..] str;
    array.init(&tokens);
    defer array.free(&tokens);

    tokenStart := 0;

    numTokens: = 0;

    for i: 0..string.length {
        if string[i] == delimiter {
            
            token: str = string[tokenStart .. i]; 
            array.push(&tokens, token);
            tokenStart = i + 1;

            numTokens += 1;
        }
    }

    // We have to return a copy otherwise the memory for the array gets freed (not sure how the copy gets deallocated though)
    return array.copy(tokens);
}


last_index_of :: (s: str, substr: str) -> i32 {
    while i := s.count - 1; i >= 0 {
        defer i -= 1;

        while j := 0; j < substr.count {
            if s[i + j] != substr[j] {
                continue continue;
            }

            j += 1;
        }

        return i;
    }

    return -1;
}

find_last :: #match #local {}

#overload
find_last :: (arr: [] $T, value: T) -> i32 {
    for i: range.{arr.count, 0, -1} {
        if value == arr.data[i] do return i;
    }

    return -1;
}

#overload
find_last :: macro (arr: [] $T/type_is_struct, pred: Code) -> i32 {
    for i: range.{arr.count, 0, -1} {
        it := &arr[i];
        if #unquote pred(it) do return i;
    }

    return -1;
}

#overload
find_last :: macro (arr: [] $T, pred: Code) -> i32 {
    for i: range.{arr.count, 0, -1} {
        it := arr[i];
        if #unquote pred(it) do return i;
    }

    return -1;
}