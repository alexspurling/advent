package day0

use core {printf}
use core.intrinsics.atomics {__atomic_wait, __atomic_notify, __atomic_cmpxchg, __atomic_store}


mutex := 0;
lock :: () {
    // Wait until the mutex is 0 as that means it's safe to render or update the game state
    // If it is 0 then set the value to 1 and exit the loop
    while __atomic_cmpxchg(&mutex, 0, 1) != 0 {
        __atomic_wait(&mutex, 1);
    }
}

unlock :: () {
    // Set the mutex back to 0 and notify any threads that are waiting
    __atomic_store(&mutex, 0);
    __atomic_notify(&mutex);
}


Pos :: struct {
    x: i32;
    y: i32;
}

// Executes on thread 0
solve :: () -> i32 {
    lock();
    printf("Starting solve\n");

    numIterations := 0;
    curPos := Pos.{0, 0};

    for i: 0 .. 1000000 {

        curPos = Pos.{curPos.x + 1, curPos.y - 1};

        numIterations += 1;

        // Yield to the render thread. Commenting out these two lines will let solve complete successfully
        // but prevents the render thread from doing anything while the solve is in progress
        unlock();
        lock();
    }

    printf("Finished solve. num iterations: {}, final pos: {}\n", numIterations, curPos);
    unlock();

    return curPos.x;
}

// Executes on thread 1
render :: () {

    lock();
    printf("Starting render\n");

    for i: 0 .. 10000 {

    }

    printf("Finished render\n");
    unlock();
}