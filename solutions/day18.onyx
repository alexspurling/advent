package day18

use canvas
use canvas {Colour}
use core.set
use common {Pos, Direction}
use core.intrinsics.atomics {__atomic_wait, __atomic_notify, __atomic_cmpxchg, __atomic_store, __atomic_load}
use core.conv {parse_int}
use core.array
use core.string
use strings {toStr}
use core {println, printf}
use core.iter
use core.math
use core.hash
use core.list


desc := "Calculate the volume of land that can be excavated by the digger following the given instructions.";

exampleInput := """R 6 (#70c710)
D 5 (#0dc571)
L 2 (#5713f0)
D 2 (#d2c081)
R 2 (#59c680)
D 2 (#411b91)
L 5 (#8ceee2)
U 2 (#caa173)
L 1 (#1b58a2)
U 2 (#caa171)
R 2 (#7807d2)
U 3 (#a77fa3)
L 2 (#015232)
U 2 (#7a21e3)""";


initialised := 0;


Instruction :: struct {
    direction: Direction;
    distance: i32;
    colour: Colour;
}

getDirection :: (d: u8) -> Direction {
    switch (d) {
        case 'U' do return Direction.NORTH;
        case 'D' do return Direction.SOUTH;
        case 'L' do return Direction.WEST;
        case 'R' do return Direction.EAST;
    }
    return Direction.UNKNOWN;
}

parseInstructionsPart1 :: (input: str) -> [..] Instruction {
    instructions := array.make(Instruction);

    for line: string.split(input, '\n') {
        items := string.split(line, ' ');

        direction := getDirection(items[0][0]);
        distance := cast(i32) parse_int(items[1]);

        r := cast(u8) parse_int(items[2][2 .. 4], 16);
        g := cast(u8) parse_int(items[2][4 .. 6], 16);
        b := cast(u8) parse_int(items[2][6 .. 8], 16);

        colour := Colour.{r, g, b, 255};

        instructions << Instruction.{direction, distance, colour};
    }

    return instructions;
}


Square :: struct {
    pos: Pos;
    colour: Colour;
}
#inject
Square.hash :: (s: Square) -> i32 {
    return hash.hash(s.pos);
}
#overload
hash.hash :: (s: Square) -> i32 {
    return hash.hash(s.pos);
}
#operator == (s1: Square, s2: Square) -> bool {
    return s1.pos == s2.pos;
}
#operator != (s1: Square, s2: Square) -> bool {
    return !(s1.pos == s2.pos);
}


grid: Set(Square);
instructions: [..] Instruction;


setup :: () {
    if __atomic_cmpxchg(&initialised, 0, 1) == 0 {
        canvas.lock();

        set.free(&grid);
        // array.free(&instructions);

        // Set the params
        input := #file_contents "inputs/day18.txt";
        // input := exampleInput;
        instructions = parseInstructionsPart1(input);

        canvas.unlock();
    }
}

getNextPos :: (curPos: Pos, direction: Direction) -> Pos {
    switch direction {
        case Direction.NORTH {
            return Pos.{curPos.x, curPos.y - 1};
        }
        case Direction.SOUTH {
            return Pos.{curPos.x, curPos.y + 1};
        }
        case Direction.EAST {
            return Pos.{curPos.x + 1, curPos.y};
        }
        case Direction.WEST {
            return Pos.{curPos.x - 1, curPos.y};
        }
    }
    return curPos;
}

getRightPos :: (curPos: Pos, direction: Direction) -> Pos {
    switch direction {
        case Direction.NORTH {
            return Pos.{curPos.x + 1, curPos.y};
        }
        case Direction.SOUTH {
            return Pos.{curPos.x - 1, curPos.y};
        }
        case Direction.EAST {
            return Pos.{curPos.x, curPos.y + 1};
        }
        case Direction.WEST {
            return Pos.{curPos.x, curPos.y - 1};
        }
    }
    return curPos;
}

excavatePerimeter :: () -> i32 {
    numSquares := 0;
    pos := Pos.{0, 0};
    // Fill the grid with all the positions described by the instructions
    for instruction: instructions {
        for d: 0 .. instruction.distance {
            pos = getNextPos(pos, instruction.direction);
            set.insert(&grid, Square.{pos, instruction.colour});
        }
        numSquares += instruction.distance;
    }
    printf("Exterior squares: {}\n", numSquares);
    return numSquares;
}

fill :: (start: Pos) -> i32 {

    numFilled := 0;

    fillSquare := Square.{start, GREY};
    if !set.has(&grid, fillSquare) {
        set.insert(&grid, fillSquare);
        numFilled += 1;
    }

    queue := list.make(Pos);
    list.push_begin(&queue, start);


    while (!list.empty(&queue)) {
        pos := list.pop_end(&queue);

        // Not putting this in a function call because that would require allocated and freeing memory for the array
        neighbours := .[Pos.{pos.x - 1, pos.y}, Pos.{pos.x, pos.y - 1}, Pos.{pos.x + 1, pos.y}, Pos.{pos.x, pos.y + 1}];
        for neighbour: neighbours {
            fillSquare := Square.{neighbour, GREY};
            if !set.has(&grid, fillSquare) {
                set.insert(&grid, fillSquare);
                list.push_begin(&queue, neighbour);
                numFilled += 1;
            }
        }

        // canvas.unlock();
        // canvas.lock();
    }

    return numFilled;
}

GREY :: Colour.{50, 50, 50, 255};

excavateInterior :: () -> i32 {
    numSquares := 0;
    pos := Pos.{0, 0};
    for instruction: instructions {
        for d: 0 .. instruction.distance {
            pos = getNextPos(pos, instruction.direction);
            // Check the position to the 'right' of this one to see if it is empty
            rightPos := getRightPos(pos, instruction.direction);

            fillSquare := Square.{rightPos, GREY};
            if !set.has(&grid, fillSquare) {
                numSquares += fill(rightPos);
            }
        }
    }
    printf("Interior squares: {}\n", numSquares);
    return numSquares;
}

calculateDigVolume :: () -> i32 {
    numSquares := excavatePerimeter();
    numSquares += excavateInterior();
    return numSquares;
}

solved := false;

solve_part_1 :: () -> str {
    __atomic_store(&initialised, 0);
    setup();
    canvas.lock();
    volume := calculateDigVolume();
    canvas.unlock();
    solved = true;
    return toStr(volume);
}

solve_part_2 :: () -> str {
    return "";
}

MIN_INT := -2147483648;
MAX_INT := 2147483647;


render :: () {

    // printf("Hi\n");
    canvas.lock();

    if __atomic_load(&initialised) == 1 {

        canvas.clear();

        // Calculate the grid width and height
        minX := set.as_iter(&grid) |> iter.map((p) => p.pos.x) |> iter.fold(MAX_INT, (t, r) => math.min(t, r));
        minY := set.as_iter(&grid) |> iter.map((p) => p.pos.y) |> iter.fold(MAX_INT, (t, r) => math.min(t, r));

        maxX := set.as_iter(&grid) |> iter.map((p) => p.pos.x) |> iter.fold(MIN_INT, (t, r) => math.max(t, r));
        maxY := set.as_iter(&grid) |> iter.map((p) => p.pos.y) |> iter.fold(MIN_INT, (t, r) => math.max(t, r));

        width := maxX - minX;
        height := maxY - minY;

        margin := 10;

        scaleX := (canvas.CANVAS_WIDTH - (margin * 2)) / (width + 1);
        scaleY := (canvas.CANVAS_HEIGHT - (margin * 2)) / (height + 1);
        scale := math.min(scaleX, scaleY);

        // Draw all the excavated squares
        for square: set.as_iter(&grid) {
            posX := margin + (square.pos.x - minX) * scale;
            posY := margin + (square.pos.y - minY) * scale;

            canvas.drawRect(posX, posY, scale, scale, square.colour);
        }

        // Show the starting position
        // posX := margin + (0 - minX) * scale;
        // posY := margin + (0 - minY) * scale;
        // canvas.drawRect(posX, posY, scale, scale, Colour.{255, 0, 0, 255});
    }


    canvas.unlock();
}