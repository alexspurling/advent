package day19

use core.array
use core.string
use core.iter
use core.conv
use core {printf}
use core.map
use strings {toStr}
use core.alloc


desc := "Process all the machine parts according to the workflows."


Operator :: enum {
    LT;
    GT;
}


ImmediateAction :: enum {
    ACCEPT;
    REJECT;
}

Action :: union {
    Immediate: ImmediateAction;
    Defer: str;
}

BasicRule :: struct {
    prop: u8;
    operator: Operator;
    value: i32;
    action: Action;
}

Rule :: union {
    Basic: BasicRule;
    Action: Action;
}

getAction :: (input: str) -> Action {
    if input == "A" {
        return Action.{Immediate = ImmediateAction.ACCEPT};
    } elseif input == "R" {
        return Action.{Immediate = ImmediateAction.REJECT};
    }
    return Action.{Defer = input};
}

getRule :: (input: str) -> Rule {
    if !string.contains(input, ':') {
        a := getAction(input);
        return Rule.{Action = a};
    }

    prop := input[0];
    operator := Operator.LT if input[1] == '<' else Operator.GT;
    valueAction := string.split(input[2 .. input.count], ':');
    value := cast(i32) conv.parse_int(valueAction[0]);
    action := getAction(valueAction[1]);

    return Rule.{Basic = .{prop, operator, value, action}};
}


getRules :: (input: str) -> [] Rule {
    return iter.as_iter(string.split(input, ','))
            |> iter.map(getRule)
            |> iter.to_array();
}


Flow :: struct {
    name: str;
    rules: [] Rule;
}

Part :: struct {
    x: i32;
    m: i32;
    a: i32;
    s: i32;
}

PartsAndFlows :: struct {
    flows: Map(str, Flow);
    parts: [] Part;
}

getFlows :: (input: str) -> Map(str, Flow) {
    lines := string.split(input, '\n');

    flows := map.make(str, Flow);
    for line: lines {
        nameAndRules := string.split(line, '{');
        name := nameAndRules[0];

        rules := getRules(nameAndRules[1][0 .. nameAndRules[1].count - 1]);

        printf("Rules: {}\n", rules);

        flow := Flow.{name, rules};
        map.put(&flows, name, flow);
    }

    return flows;
}

getPart :: (input: str) -> Part {
    x := 0;
    m := 0;
    a := 0;
    s := 0;
    props := input[1 .. input.count - 1];
    for prop: string.split(props, ',') {
        value := cast(i32) conv.parse_int(prop[2 .. prop.count]);
        switch prop[0] {
            case 'x' do x = value;
            case 'm' do m = value;
            case 'a' do a = value;
            case 's' do s = value;
        }
    }
    p := Part.{x, m, a, s};
    printf("{}\n", p);
    return p;
}

getParts :: (input: str) -> [] Part {
    lines := string.split(input, '\n');

    return iter.as_iter(string.split(input, '\n'))
            |> iter.map(getPart)
            |> iter.to_array();
}

getPartsAndFlows :: (input: str) -> PartsAndFlows {
    input_split := string.split_iter(input, "\n\n");

    flows_input, cont1 := iter.take_one(input_split);
    parts_input, cont2 := iter.take_one(input_split);

    flows := getFlows(flows_input);
    parts := getParts(parts_input);

    return PartsAndFlows.{flows, parts};
}

evalOperator :: (value1: i32, operator: Operator, value2: i32) -> bool {
    switch operator {
        case Operator.LT {
            return value1 < value2;
        }
        case Operator.GT {
            return value1 > value2;
        }
    }
    return false;
}

evalRule :: (part: Part, rule: BasicRule) -> bool {
    switch rule.prop {
        case 'x' do return evalOperator(part.x, rule.operator, rule.value);
        case 'm' do return evalOperator(part.m, rule.operator, rule.value);
        case 'a' do return evalOperator(part.a, rule.operator, rule.value);
        case 's' do return evalOperator(part.s, rule.operator, rule.value);
    }
    return false;
}

process :: (partsAndFlows: PartsAndFlows) -> i32 {

    accepted := array.make(Part);

    iterCount := 0;
    for part: partsAndFlows.parts {
        printf("Processing part: {}\n", part);
        // Start with the "in" workflow
        nextFlow := "in";
        partProcessed := false;
        while !partProcessed {
            iterCount += 1;
            printf("Getting flow: {}\n", nextFlow);
            flow := map.get(&partsAndFlows.flows, nextFlow)->unwrap();
            printf("Flow: {}\n", flow);
            ruleProcessed := false;
            for rule: flow.rules {
                switch rule {
                    case br: .Basic {
                        printf("Basic rule: {}\n", br);
                        if evalRule(part, br) {
                            printf("Part {} matches rule: {}\n", part, br);
                            switch br.action {
                                case ia: .Immediate {
                                    if ia == ImmediateAction.ACCEPT {
                                        printf("Part accepted: {}\n", part);
                                        accepted << part;
                                    } else {
                                        printf("Part rejected: {}\n", part);
                                    }
                                    partProcessed = true;
                                }
                                case d: .Defer {
                                    nextFlow = d;
                                }
                            }
                            ruleProcessed = true;
                        } else {
                            printf("Part {} does not match rule: {}\n", part, br);
                        }
                    }
                    case a: .Action {
                        printf("Action: {}\n", a);
                        switch a {
                            case ia: .Immediate {
                                if ia == ImmediateAction.ACCEPT {
                                    printf("Part accepted: {}\n", part);
                                    accepted << part;
                                } else {
                                    printf("Part rejected: {}\n", part);
                                }
                                partProcessed = true;
                            }
                            case d: .Defer {
                                nextFlow = d;
                            }
                        }
                        ruleProcessed = true;
                    }
                }
                if ruleProcessed {
                    break;
                }
            }
        }
    }

    return iter.as_iter(accepted)
        |> iter.map(p => p.x + p.m + p.a + p.s)
        |> iter.sum();
}

solve_part_1 :: () -> str {
    // input := #file_contents "inputs/day19.txt";
    partsAndFlows := getPartsAndFlows(exampleInput);
    sumAcceptedParts := process(partsAndFlows);
    return toStr(sumAcceptedParts);
}

#tag conv.Custom_Format.{ formatPartRanges }
PartRanges :: struct {
    x: [] bool;
    m: [] bool;
    a: [] bool;
    s: [] bool;
}


formatRange :: (output: &conv.Format_Output, prop: u8, range: [] bool) {

    conv.format(output, "\n  {}: [", prop);

    rangeStart := -1;
    rangeEnd := -1;

    for i: 0 .. range.count {
        if rangeStart == -1 && range[i] {
            rangeStart = i;
        } elseif rangeStart != -1 && !range[i] {
            rangeEnd = i - 1;
            conv.format(output, "{}-{}, ", rangeStart, rangeEnd);
            rangeStart = -1;
            rangeEnd = -1;
        }
    }
    if rangeStart != -1 {
        conv.format(output, "{}-{}", rangeStart, range.count - 1);
    }

    conv.format(output, "]");
}


formatPartRanges :: (output: &conv.Format_Output, format: &conv.Format, range: &PartRanges) {
    conv.format(output, "PartsRanges{");
    formatRange(output, 'x', range.x);
    formatRange(output, 'm', range.m);
    formatRange(output, 'a', range.a);
    formatRange(output, 's', range.s);
    conv.format(output, "\n}");
}

newRange :: (max: i32) -> [] bool {
    range := array.make(bool, capacity = max + 1);

    range << false; // We always want a false entry at index 0
    for i: 0 .. max {
        range << true;
    }

    return range;
}

newRanges :: () -> &PartRanges {
    return alloc.on_heap(PartRanges.{
        newRange(4000),
        newRange(4000),
        newRange(4000),
        newRange(4000)
    });
}

copyRanges :: (ranges: PartRanges) -> &PartRanges {
    rangesCopy := newRanges();

    for i: 0 .. rangesCopy.x.count {
        rangesCopy.x[i] = ranges.x[i];
        rangesCopy.m[i] = ranges.m[i];
        rangesCopy.a[i] = ranges.a[i];
        rangesCopy.s[i] = ranges.s[i];
    }

    return rangesCopy;
}

combineRange :: #match #local {}

#overload
combineRange :: (curRange: [] bool, newRange: [] bool) {
    combineRange(curRange, newRange, 0, curRange.count - 1);
}

#overload
combineRange :: (curRange: [] bool, newRange: [] bool, min: i32, max: i32) {
    // Add any new exclusions within the given range
    for i: min .. max + 1 {
        curRange[i] = curRange[i] && newRange[i];
    }
}

combineRanges :: (curRanges: PartRanges, newRanges: PartRanges, rule: BasicRule) {
    // x: [] bool = newRange(4000);
    // m: [] bool = newRange(4000);
    // a: [] bool = newRange(4000);
    // s: [] bool = newRange(4000);

    min: i32;
    max: i32;
    if rule.operator == Operator.LT {
        min = 1;
        max = rule.value - 1;
    } else {
        min = rule.value + 1;
        max = curRanges.x.count - 1;
    }
    if rule.prop == 'x' {
        combineRange(curRanges.x, newRanges.x, min, max);
    } else {
        combineRange(curRanges.x, newRanges.x);
    }
    if rule.prop == 'm' {
        combineRange(curRanges.m, newRanges.m, min, max);
    } else {
        combineRange(curRanges.m, newRanges.m);
    }
    if rule.prop == 'a' {
        combineRange(curRanges.a, newRanges.a, min, max);
    } else {
        combineRange(curRanges.a, newRanges.a);
    }
    if rule.prop == 's' {
        combineRange(curRanges.s, newRanges.s, min, max);
    } else {
        combineRange(curRanges.s, newRanges.s);
    }

    printf("New combined ranges: {}\n", curRanges);
}

excludeRanges :: #match #local {}

#overload
excludeRanges :: (curRanges: PartRanges, rule: BasicRule) {

    rangeToUpdate : [] bool;
    switch rule.prop {
        case 'x' do rangeToUpdate = curRanges.x;
        case 'm' do rangeToUpdate = curRanges.m;
        case 'a' do rangeToUpdate = curRanges.a;
        case 's' do rangeToUpdate = curRanges.s;
    }

    min: i32;
    max: i32;
    if rule.operator == Operator.LT {
        min = 1;
        max = rule.value - 1;
    } else {
        min = rule.value + 1;
        max = rangeToUpdate.count - 1;
    }

    for i: min .. max + 1 {
        rangeToUpdate[i] = false;
    }
}

#overload
excludeRanges :: (curRanges: PartRanges, rangesToExclude: PartRanges) {
    for i: 0 .. curRanges.x.count {
        curRanges.x[i] = curRanges.x[i] && !rangesToExclude.x[i];
        curRanges.m[i] = curRanges.m[i] && !rangesToExclude.m[i];
        curRanges.a[i] = curRanges.a[i] && !rangesToExclude.a[i];
        curRanges.s[i] = curRanges.s[i] && !rangesToExclude.s[i];
    }
}

getAcceptedPartRanges :: #match #local {}

#overload
getAcceptedPartRanges :: (flows: &Map(str, Flow)) -> PartRanges {
    return getAcceptedPartRanges(flows, "in", *newRanges());
}

oppositeRule :: (basicRule: BasicRule) -> BasicRule {
    if basicRule.operator == Operator.LT {
        return BasicRule.{basicRule.prop, Operator.GT, basicRule.value - 1, basicRule.action};
    } else {
        return BasicRule.{basicRule.prop, Operator.LT, basicRule.value + 1, basicRule.action};
    }
}

#overload
getAcceptedPartRanges :: (flows: &Map(str, Flow), name: str, inRanges: PartRanges) -> PartRanges {

    printf("Processing flow {} with valid ranges: {}\n", name, inRanges);
    flow := map.get(flows, name)->unwrap();

    // Use this to keep track of the ranges that the final workflow rule applies to
    workflowRanges := *newRanges();
    ranges := *copyRanges(inRanges);

    for rule: flow.rules {
        switch rule {
            case br: .Basic {
                printf("Applying rule: {}\n", br);
                switch br.action {
                    case ia: .Immediate {
                        // If this is a reject rule, then we can constrain the allowed ranges
                        if ia == ImmediateAction.REJECT {
                            // Remove this range from existing ranges
                            printf("Excluding ranges due to rule: {}\n", br);
                            printf("Before ranges: {}\n", ranges);
                            excludeRanges(ranges, br);
                            printf("Updated ranges: {}\n", ranges);

                            printf("Workflow ranges: {}\n", workflowRanges);
                            oppoRule := oppositeRule(br);
                            printf("Excluding ranges from workflow ranges according to opposite rule {}\n", oppoRule);
                            excludeRanges(workflowRanges, oppoRule);
                            printf("Updated workflow ranges: {}\n", workflowRanges);
                        }
                    }
                    case deferTo: .Defer {
                        printf("Deferring according to rule: {}\n", br);
                        deferredRanges := getAcceptedPartRanges(flows, deferTo, ranges);
                        printf("Deferred ranges: {}\n", deferredRanges);
                        // Combine ranges considering the rule
                        printf("Combining with: {}\n", ranges);
                        combineRanges(ranges, deferredRanges, br);
                        printf("Combined ranges: {}\n", ranges);
                        printf("Workflow ranges: {}\n", workflowRanges);
                        excludeRanges(workflowRanges, br);
                        printf("Excluded workflow ranges: {}\n", workflowRanges);
                    }
                }
            }
            case a: .Action {
                printf("Applying action: {}\n", a);
                switch a {
                    case ia: .Immediate {
                        if ia == ImmediateAction.REJECT {
                            // Reject all workflow ranges
                            excludeRanges(ranges, workflowRanges);
                        }
                    }
                    case deferTo: .Defer {
                        ranges = getAcceptedPartRanges(flows, deferTo, ranges);
                    }
                }
            }
        }
    }
    return ranges;
}

solve_part_2 :: () -> str {
    // input := #file_contents "inputs/day19.txt";
    partsAndFlows := getPartsAndFlows(exampleInput);
    acceptedParts := getAcceptedPartRanges(&partsAndFlows.flows);
    printf("Final accepted ranges: {}\n", acceptedParts);

    return "";
}

// example := """in{s<1716:qqz,s<100:bum,a<3500:R,A}
// qqz{x>2770:R,m<1801:R,A}
// bum{R}

// """;

exampleInput := """px{a<2006:qkq,m>2090:A,rfg}
pv{a>1716:R,A}
lnx{m>1548:A,A}
rfg{s<537:gd,x>2440:R,A}
qs{s>3448:A,lnx}
qkq{x<1416:A,crn}
crn{x>2662:A,R}
in{s<1351:px,qqz}
qqz{s>2770:qs,m<1801:hdj,R}
gd{a>3333:R,R}
hdj{m>838:A,pv}

{x=787,m=2655,a=1222,s=2876}
{x=1679,m=44,a=2067,s=496}
{x=2036,m=264,a=79,s=2244}
{x=2461,m=1339,a=466,s=291}
{x=2127,m=1623,a=2188,s=1013}""";
