package day17

use core
use core.iter
use core.map
use core {println, printf}
use core.string
use core.array
use core.set
use core.hash
use core.conv {parse_int}
use strings {toStr}
use common {Pos, cmp, Direction, progress}
use core.heap
use canvas
use canvas {Colour}
use core.intrinsics.atomics {__atomic_wait, __atomic_notify, __atomic_cmpxchg, __atomic_store, __atomic_load}


desc := "Find the best path to transport the lava crucible through the city from the laval pool to the machine parts factory."


MAX_INT :: 2147483647;


getCityCost :: (city: [] str, pos: Pos) -> i32 {
    costChar := city[pos.y][pos.x];
    costInt := cast(i32) costChar;
    return costInt - 48;
}

CrucibleState :: struct {
    pos: Pos;
    direction: Direction;
    numSteps: i32;
    distance: i32;
}
#operator == (p1: CrucibleState, p2: CrucibleState) -> bool {
    return p1.pos == p2.pos && p1.direction == p2.direction && p1.numSteps == p2.numSteps;
}
#inject
CrucibleState.hash :: (p: CrucibleState) -> u32 {
    return 31 * hash.hash(p.pos) * hash.hash(p.direction) * hash.hash(p.numSteps);
}
#overload
hash.hash :: (p: CrucibleState) -> u32 {
    return 31 * hash.hash(p.pos) * hash.hash(p.direction) * hash.hash(p.numSteps);
}

getDirection :: (curPos: Pos, nextPos: Pos) -> Direction {
    if curPos.y > nextPos.y {
        return Direction.NORTH;
    }
    if curPos.y < nextPos.y {
        return Direction.SOUTH;
    }
    if curPos.x < nextPos.x {
        return Direction.EAST;
    }
    return Direction.WEST;
}


city: [] str;
startPos: Pos;
targetPos: Pos;
distances : Map(CrucibleState, i32);
visited : Set(CrucibleState);
prev : Map(CrucibleState, CrucibleState);
queue : heap.Heap(CrucibleState);

// Variables used for visualisation
lastCrucibleState : CrucibleState;
recentlyUpdatedDistances: [..] Pos;
minDistances : Map(Pos, i32);

initialised := 0;


setup :: () {
    if __atomic_cmpxchg(&initialised, 0, 1) == 0 {
        canvas.lock();

        // Set the params
        input := #file_contents "inputs/day17.txt";
        city = string.split(input, '\n');
        startPos = Pos.{0, 0};
        targetPos = Pos.{city[0].length - 1, city.length - 1};

        // Initialise the search
        distances = map.make(CrucibleState, i32);
        visited = set.make(CrucibleState);
        prev = map.make(CrucibleState, CrucibleState);
        queue = heap.make(CrucibleState, (p1, p2) => cmp(p1.distance, p2.distance));
        queue << CrucibleState.{startPos, Direction.UNKNOWN, 0};

        minDistances = map.make(Pos, i32);
        map.put(&minDistances, startPos, 0);
        canvas.unlock();
    }
}

solve_part_1 :: () -> str {
    printf("Solving...\n");
    __atomic_store(&initialised, 0);
    setup();
    while !array.empty(queue.data) {
        getShortestPathStep();
    }
    printf("Solved...\n");
    return toStr(lastCrucibleState.distance);
}

solve_part_2 :: () -> str {
    return "";
}


opposite :: (d: Direction) -> Direction {
    switch d {
        case Direction.NORTH do return Direction.SOUTH;
        case Direction.SOUTH do return Direction.NORTH;
        case Direction.EAST do return Direction.WEST;
        case Direction.WEST do return Direction.EAST;
    }
    return Direction.UNKNOWN;
}

NEIGHBOURS :: .[Pos.{0, 1}, Pos.{1, 0}, Pos.{0, -1}, Pos.{-1, 0}];

getShortestPathStep :: () {
    canvas.lock();

    curState := heap.remove_top(&queue);

    lastCrucibleState = curState;

    if curState.pos == targetPos {
        printf("Found solution: {} with queue size {}\n", curState, queue.data.count);
        // map.put(&distances, curState, curState.distance);
        // empty the queue
        while !array.empty(queue.data) {
            heap.remove_top(&queue);
        }
    } elseif !set.has(&visited, curState) {
        set.insert(&visited, curState);

        curDirection := curState.direction;
        curDistance := curState.distance;

        neighbours: [4] Pos = NEIGHBOURS;
        for n: neighbours {
            neighbour := Pos.{curState.pos.x + n.x, curState.pos.y + n.y};
            if neighbour.x >= 0 && neighbour.x < city[0].count && neighbour.y >= 0 && neighbour.y < city.count {
                blockCost := getCityCost(city, neighbour);
                neighbourDistance := curDistance + blockCost;
                neighbourDirection := getDirection(curState.pos, neighbour);
                neighbourState: CrucibleState;

                if neighbourDirection == curDirection && curState.numSteps < 3 {
                    neighbourState = CrucibleState.{neighbour, neighbourDirection, curState.numSteps + 1, neighbourDistance};
                } elseif neighbourDirection != curDirection && neighbourDirection != opposite(curDirection) {
                    neighbourState = CrucibleState.{neighbour, neighbourDirection, 1, neighbourDistance};
                }
                queue << neighbourState;

                if neighbourDistance < map.get(&distances, neighbourState)->value_or(MAX_INT) {
                    map.put(&distances, neighbourState, neighbourDistance);
                    map.put(&prev, neighbourState, curState);
                }
                if neighbourDistance < map.get(&minDistances, neighbour)->value_or(MAX_INT) {
                    map.put(&minDistances, neighbour, neighbourDistance);
                }
            }
        }
    }

    canvas.unlock();
}

renderCell :: (posX: i32, posY: i32, distance: i32, colour: Colour) {
    if distance < 10 {
        canvas.drawChar('0', posX, posY, colour);
        canvas.drawChar(cast(u8) ('0' + distance), posX + 10, posY, colour);
    } elseif distance < 100 {
        canvas.drawChar(cast(u8) ('0' + distance / 10), posX, posY, colour);
        canvas.drawChar(cast(u8) ('0' + distance % 10), posX + 10, posY, colour);
    } elseif distance < 1000 {
        canvas.drawChar(cast(u8) ('0' + distance / 100), posX - 5, posY, colour);
        canvas.drawChar(cast(u8) ('0' + (distance / 10) % 10), posX + 5, posY, colour);
        canvas.drawChar(cast(u8) ('0' + distance % 10), posX + 15, posY, colour);
    }
}

render :: () {

    canvas.lock();

    canvas.clear();

    if __atomic_load(&initialised) == 1 {

        canvas.drawRect(0, 0, 750, 750, Colour.{100, 0, 0, 255});

        // Render all calculated distances
        for y: 0 .. city.count {
            for x: 0 .. city[0].count {
                pos := Pos.{x, y};

                distance := map.get(&minDistances, pos);

                if distance == .None {
                } else {
                    posX := 22 + x * 5;
                    posY := 22 + y * 5;

                    distanceValue := 255 * cast(f64) distance->unwrap() / 1024.0;
                    distanceInt := cast(u8) cast(i32) distanceValue;
                    y := 255 - distanceInt;

                    canvas.drawRect(posX, posY, 5, 5, Colour.{255, y, 100, 255});
                }
            }
        }

        // Render most recent state
        posX := 22 + lastCrucibleState.pos.x * 5;
        posY := 22 + lastCrucibleState.pos.y * 5;
        canvas.drawRect(posX, posY, 4, 4, Colour.{255, 0, 0, 255});

        // Draw the path to the most recent state
        initialState := CrucibleState.{startPos, Direction.UNKNOWN, 0};
        prevState := map.get(&prev, lastCrucibleState)->value_or(initialState);

        pathLength := 0;
        while prevState.pos != Pos.{0, 0} && pathLength < 1024 {
            posX := 22 + prevState.pos.x * 5;
            posY := 22 + prevState.pos.y * 5;
            canvas.drawRect(posX, posY, 4, 4, Colour.{0, 0, 255, 255});
            prevState = map.get(&prev, prevState)->value_or(initialState);
            pathLength += 1;
        }

    }

    canvas.unlock();
}

