package day17

use core
use core.iter
use core.map
use core {println, printf}
use core.string
use core.array
use core.set
use core.hash
use core.conv {parse_int}
use strings {toStr}
use common {Pos, cmp, Direction, progress}
use core.heap
use canvas
use canvas {Colour}
use core.intrinsics.atomics {__atomic_load, __atomic_store}


desc := "Find the best path to transport the lava crucible through the city from the laval pool to the machine parts factory."


MAX_INT :: 2147483647;


getCityCost :: (city: [] str, pos: Pos) -> i32 {
    costChar := city[pos.y][pos.x];
    costInt := cast(i32) costChar;
    return costInt - 48;
}

CrucibleState :: struct {
    pos: Pos;
    direction: Direction;
    numSteps: i32;
    distance: i32;
}
#operator == (p1: CrucibleState, p2: CrucibleState) -> bool {
    return p1.pos == p2.pos && p1.direction == p2.direction && p1.numSteps == p2.numSteps;
}
#inject
CrucibleState.hash :: (p: CrucibleState) -> u32 {
    return 31 * hash.hash(p.pos) * hash.hash(p.direction) * hash.hash(p.numSteps);
}
#overload
hash.hash :: (p: CrucibleState) -> u32 {
    return 31 * hash.hash(p.pos) * hash.hash(p.direction) * hash.hash(p.numSteps);
}

getDirection :: (curPos: Pos, nextPos: Pos) -> Direction {
    if curPos.y > nextPos.y {
        return Direction.NORTH;
    }
    if curPos.y < nextPos.y {
        return Direction.SOUTH;
    }
    if curPos.x < nextPos.x {
        return Direction.EAST;
    }
    return Direction.WEST;
}

opposite :: (d: Direction) -> Direction {
    switch d {
        case Direction.NORTH do return Direction.SOUTH;
        case Direction.SOUTH do return Direction.NORTH;
        case Direction.EAST do return Direction.WEST;
        case Direction.WEST do return Direction.EAST;
    }
    return Direction.UNKNOWN;
}


city: [] str;
distances : Map(CrucibleState, i32);
visited : Set(CrucibleState);
queue : heap.Heap(CrucibleState);


// Variables used for visualisation
lastCrucibleState : CrucibleState;
prev : Map(CrucibleState, CrucibleState);
// recentlyUpdatedDistances: [..] Pos;
// minDistances : Map(Pos, i32);


initialised := 0;
setInitialised :: (setTo: i32) {
    __atomic_store(&initialised, setTo);
}


solve_part_1 :: () -> str {

    canvas.lock();
    // printf("Starting to solve part 1\n");
    input := #file_contents "inputs/day17.txt";

    city := string.split(input, '\n');

    // printf("City: {}\n", &city);

    startPos := Pos.{0, 0};
    targetPos := Pos.{city[0].length - 1, city.length - 1};

    distances := map.make(CrucibleState, i32);
    visited := set.make(CrucibleState);
    prev = map.make(CrucibleState, CrucibleState);
    queue := heap.make(CrucibleState, (p1: CrucibleState, p2: CrucibleState) => cmp(p1.distance, p2.distance));

    lastCrucibleState = CrucibleState.{startPos, Direction.UNKNOWN, 0};
    queue << lastCrucibleState;

    numSteps := 0;

    // Don't allow render() to do anything while shared objects are uninitialised
    setInitialised(1);
    canvas.unlock();

    while !array.empty(queue.data) {
        canvas.lock();

        curState := heap.remove_top(&queue);

        // printf("Current state: {}\n", curState);

        lastCrucibleState = curState;

        if curState.pos == targetPos {
            // printf("Found solution: {} with queue size {}\n", curState, queue.data.count);
            // map.put(&distances, curState, curState.distance);
            while !array.empty(queue.data) {
                // empty the queue
                heap.remove_top(&queue);
            }
        } elseif !set.has(&visited, curState) {
            set.insert(&visited, curState);

            curDirection := curState.direction;
            curDistance := curState.distance;

            neighbours: [4] Pos = .[Pos.{0, 1}, Pos.{1, 0}, Pos.{0, -1}, Pos.{-1, 0}];
            for n: neighbours {
                neighbour := Pos.{curState.pos.x + n.x, curState.pos.y + n.y};
                if neighbour.x >= 0 && neighbour.x < city[0].count && neighbour.y >= 0 && neighbour.y < city.count {
                    blockCost := getCityCost(city, neighbour);
                    neighbourDistance := curDistance + blockCost;
                    neighbourDirection := getDirection(curState.pos, neighbour);
                    neighbourState: CrucibleState;

                    if neighbourDirection == curDirection && curState.numSteps < 3 {
                        neighbourState = CrucibleState.{neighbour, neighbourDirection, curState.numSteps + 1, neighbourDistance};
                    } elseif neighbourDirection != curDirection && neighbourDirection != opposite(curDirection) {
                        neighbourState = CrucibleState.{neighbour, neighbourDirection, 1, neighbourDistance};
                    }
                    heap.insert(&queue, neighbourState);

                    // if neighbourDistance < map.get(&minDistances, neighbour)->value_or(MAX_INT) {
                    //     map.put(&minDistances, neighbour, neighbourDistance);
                    //     map.put(&prev, neighbourState, curState);
                    // }

                    // printf("Adding neighbour ({}, {})\n", neighbour.x, neighbour.y);
                }
            }
        }

        canvas.unlock();
        if numSteps % 50000 == 0 {
            progress(cast(f64) numSteps / 9333);
        }
        numSteps += 1;
    }

    // If the render function is still running then wait until it finishes before setting resetting initialised flag
    // This will allow us to free any shared data and avoid concurrent access
    canvas.lock();
    setInitialised(0);
    map.free(&distances);
    set.free(&visited);
    map.free(&prev);
    array.free(&queue.data);
    canvas.unlock();

    return toStr(lastCrucibleState.distance);
}

render :: () {

    if __atomic_load(&initialised) == 0 {
        return;
    }

    canvas.lock();
    // canvas.clear();

    posX := 25 + lastCrucibleState.pos.x * 5;
    posY := 25 + lastCrucibleState.pos.y * 5;

    canvas.drawRect(posX, posY, 4, 4, Colour.{255, 0, 0, 255});

    // Uncommenting this line will break the solver thread for some reason
    // initialState := CrucibleState.{Pos.{0, 0}, Direction.UNKNOWN, 0};

    for i: 0 .. 0 {

    }


    // prevState := map.get(&prev, lastCrucibleState)->value_or(initialState);

    // while prevState.pos != Pos.{0, 0} {
    //     posX := 25 + prevState.pos.x * 5;
    //     posY := 25 + prevState.pos.y * 5;
    //     canvas.drawRect(posX, posY, 4, 4, Colour.{0, 0, 255, 255});
    //     prevState = map.get(&prev, prevState)->value_or(initialState);
    // }

    canvas.unlock();
}


solve_part_2 :: () -> str {
    return "";
}


exampleInput := """2413432311323
3215453535623
3255245654254
3446585845452
4546657867536
1438598798454
4457876987766
3637877979653
4654967986887
4564679986453
1224686865563
2546548887735
4322674655533""";