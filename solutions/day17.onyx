package day17

use core
use core.iter
use core.map
use core {println, printf}
use core.string
use core.array
use core.set
use core.hash
use core.conv {parse_int}
use strings {toStr}
use common {Pos, cmp, Direction, progress}
use core.heap
use canvas
use canvas {Colour}
use core.intrinsics.atomics {__atomic_load, __atomic_store}


desc := "Find the best path to transport the lava crucible through the city from the laval pool to the machine parts factory."


MAX_INT :: 2147483647;


getCityCost :: (city: [] str, pos: Pos) -> i32 {
    costChar := city[pos.y][pos.x];
    costInt := cast(i32) costChar;
    return costInt - 48;
}

CrucibleState :: struct {
    pos: Pos;
    direction: Direction;
    numSteps: i32;
    distance: i32;
}
#operator == (p1: CrucibleState, p2: CrucibleState) -> bool {
    return p1.pos == p2.pos && p1.direction == p2.direction && p1.numSteps == p2.numSteps;
}
#inject
CrucibleState.hash :: (p: CrucibleState) -> u32 {
    return 31 * hash.hash(p.pos) * hash.hash(p.direction) * hash.hash(p.numSteps);
}
#overload
hash.hash :: (p: CrucibleState) -> u32 {
    return 31 * hash.hash(p.pos) * hash.hash(p.direction) * hash.hash(p.numSteps);
}

getDirection :: (curPos: Pos, nextPos: Pos) -> Direction {
    if curPos.y > nextPos.y {
        return Direction.NORTH;
    }
    if curPos.y < nextPos.y {
        return Direction.SOUTH;
    }
    if curPos.x < nextPos.x {
        return Direction.EAST;
    }
    return Direction.WEST;
}

opposite :: (d: Direction) -> Direction {
    switch d {
        case Direction.NORTH do return Direction.SOUTH;
        case Direction.SOUTH do return Direction.NORTH;
        case Direction.EAST do return Direction.WEST;
        case Direction.WEST do return Direction.EAST;
    }
    return Direction.UNKNOWN;
}


// Variables used for visualisation
lastCrucibleState : CrucibleState;
prev : Map(CrucibleState, CrucibleState);
// recentlyUpdatedDistances: [..] Pos;
// minDistances : Map(Pos, i32);



getShortestPathStep :: (city: [] str, targetPos: Pos, distances: &Map(CrucibleState, i32), visited: &Set(CrucibleState),
                        queue: &heap.Heap(CrucibleState)) -> CrucibleState {
    canvas.lock();

    curState := heap.remove_top(queue);

    lastCrucibleState = curState;

    if curState.pos == targetPos {
        printf("Found solution: {} with queue size {}\n", curState, queue.data.count);
        // map.put(&distances, curState, curState.distance);
        while !array.empty(queue.data) {
            // empty the queue
            heap.remove_top(queue);
        }
    } elseif !set.has(visited, curState) {
        set.insert(visited, curState);

        curDirection := curState.direction;
        curDistance := curState.distance;

        neighbours: [4] Pos = .[Pos.{0, 1}, Pos.{1, 0}, Pos.{0, -1}, Pos.{-1, 0}];
        for n: neighbours {
            neighbour := Pos.{curState.pos.x + n.x, curState.pos.y + n.y};
            if neighbour.x >= 0 && neighbour.x < city[0].count && neighbour.y >= 0 && neighbour.y < city.count {
                blockCost := getCityCost(city, neighbour);
                neighbourDistance := curDistance + blockCost;
                neighbourDirection := getDirection(curState.pos, neighbour);
                neighbourState: CrucibleState;

                if neighbourDirection == curDirection && curState.numSteps < 3 {
                    neighbourState = CrucibleState.{neighbour, neighbourDirection, curState.numSteps + 1, neighbourDistance};
                } elseif neighbourDirection != curDirection && neighbourDirection != opposite(curDirection) {
                    neighbourState = CrucibleState.{neighbour, neighbourDirection, 1, neighbourDistance};
                }
                heap.insert(queue, neighbourState);
                map.put(&prev, neighbourState, curState);
                // printf("Adding neighbour ({}, {})\n", neighbour.x, neighbour.y);
            }
        }
    }

    canvas.unlock();

    return curState;
}

initialised := 0;
setInitialised :: (setTo: i32) {
    __atomic_store(&initialised, setTo);
}


solve_part_1 :: () -> str {

    printf("Starting to solve part 1\n");
    input := #file_contents "inputs/day17.txt";

    city := string.split(input, '\n');
    startPos := Pos.{0, 0};
    targetPos := Pos.{city[0].length - 1, city.length - 1};

    distances := map.make(CrucibleState, i32);
    defer map.free(&distances);
    visited := set.make(CrucibleState);
    defer set.free(&visited);
    prev = map.make(CrucibleState, CrucibleState);
    defer map.free(&prev);
    queue := heap.make(CrucibleState, (p1: CrucibleState, p2: CrucibleState) => cmp(p1.distance, p2.distance));
    defer array.free(&queue.data);

    lastCrucibleState = CrucibleState.{startPos, Direction.UNKNOWN, 0};
    queue << lastCrucibleState;

    curState: CrucibleState;
    numSteps := 0;

    // Don't allow render() to do anything shared objects are uninitialised
    setInitialised(1);

    while !array.empty(queue.data) {
        curState = getShortestPathStep(city, targetPos, &distances, &visited, &queue);
        if numSteps % 50000 == 0 {
            progress(cast(f64) numSteps / 9333);
        }
        numSteps += 1;
    }

    // If the render function is still running then wait until it finishes before setting resetting initialised flag
    // This will allow us to free any shared data and avoid illegal access
    canvas.lock();
    setInitialised(0);
    canvas.unlock();

    return toStr(curState.distance);
}

render :: () {

    if __atomic_load(&initialised) == 0 {
        return;
    }

    canvas.lock();
    canvas.clear();

    posX := 25 + lastCrucibleState.pos.x * 5;
    posY := 25 + lastCrucibleState.pos.y * 5;

    // if (lastCrucibleState.pos.x == 0 && lastCrucibleState.pos.y == 0) {
        // printf("Render state is 0\n");
    // }

    canvas.drawRect(posX, posY, 4, 4, Colour.{255, 0, 0, 255});

    // initialState := CrucibleState.{Pos.{0, 0}, Direction.UNKNOWN, 0};
    // prevState := map.get(&prev, lastCrucibleState)->value_or(initialState);
    // while prevState.pos != Pos.{0, 0} {
    //     posX := 25 + prevState.pos.x * 5;
    //     posY := 25 + prevState.pos.y * 5;
    //     canvas.drawRect(posX, posY, 4, 4, Colour.{0, 0, 255, 255});
    //     prevState = map.get(&prev, prevState)->value_or(initialState);
    // }

    canvas.unlock();
}


solve_part_2 :: () -> str {
    return "";
}


exampleInput := """2413432311323
3215453535623
3255245654254
3446585845452
4546657867536
1438598798454
4457876987766
3637877979653
4654967986887
4564679986453
1224686865563
2546548887735
4322674655533""";