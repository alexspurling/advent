package day17

use core
use core.iter
use core.map
use core {println, printf}
use core.string
use core.array
use core.set
use core.hash
use core.conv {parse_int}
use strings {toStr}
use common {Pos, cmp, Direction, progress}
use core.heap
use canvas
use canvas {Colour}


desc := "Find the best path to transport the lava crucible through the city from the laval pool to the machine parts factory."


MAX_INT :: 2147483647;


getCityCost :: (city: [] str, pos: Pos) -> i32 {
    costChar := city[pos.y][pos.x];
    costInt := cast(i32) costChar;
    return costInt - 48;
}

CrucibleState :: struct {
    pos: Pos;
    direction: Direction;
    numSteps: i32;
    distance: i32;
}
#operator == (p1: CrucibleState, p2: CrucibleState) -> bool {
    return p1.pos == p2.pos && p1.direction == p2.direction && p1.numSteps == p2.numSteps;
}
#inject
CrucibleState.hash :: (p: CrucibleState) -> u32 {
    return 31 * hash.hash(p.pos) * hash.hash(p.direction) * hash.hash(p.numSteps);
}
#overload
hash.hash :: (p: CrucibleState) -> u32 {
    return 31 * hash.hash(p.pos) * hash.hash(p.direction) * hash.hash(p.numSteps);
}

getDirection :: (curPos: Pos, nextPos: Pos) -> Direction {
    if curPos.y > nextPos.y {
        return Direction.NORTH;
    }
    if curPos.y < nextPos.y {
        return Direction.SOUTH;
    }
    if curPos.x < nextPos.x {
        return Direction.EAST;
    }
    return Direction.WEST;
}

opposite :: (d: Direction) -> Direction {
    switch d {
        case Direction.NORTH do return Direction.SOUTH;
        case Direction.SOUTH do return Direction.NORTH;
        case Direction.EAST do return Direction.WEST;
        case Direction.WEST do return Direction.EAST;
    }
    return Direction.UNKNOWN;
}


// Variables used for visualisation
// lastCrucibleState : CrucibleState;
// recentlyUpdatedDistances: [..] Pos;
// minDistances : Map(Pos, i32);



getShortestPathStep :: (city: [] str, targetPos: Pos, distances: &Map(CrucibleState, i32), visited: &Set(CrucibleState),
                        prev: &Map(CrucibleState, CrucibleState), queue: &heap.Heap(CrucibleState)) -> CrucibleState {
    canvas.lock();

    curState := heap.remove_top(queue);

    // lastCrucibleState = curState;

    if curState.pos == targetPos {
        printf("Found solution: {} with queue size {}\n", curState, queue.data.count);
        // map.put(&distances, curState, curState.distance);
        while !array.empty(queue.data) {
            // empty the queue
            heap.remove_top(queue);
        }
    } elseif !set.has(visited, curState) {
        set.insert(visited, curState);

        curDirection := curState.direction;
        curDistance := curState.distance;

        neighbours: [4] Pos = .[Pos.{0, 1}, Pos.{1, 0}, Pos.{0, -1}, Pos.{-1, 0}];
        for n: neighbours {
            neighbour := Pos.{curState.pos.x + n.x, curState.pos.y + n.y};
            if neighbour.x >= 0 && neighbour.x < city[0].count && neighbour.y >= 0 && neighbour.y < city.count {
                blockCost := getCityCost(city, neighbour);
                neighbourDistance := curDistance + blockCost;
                neighbourDirection := getDirection(curState.pos, neighbour);
                neighbourState: CrucibleState;

                if neighbourDirection == curDirection && curState.numSteps < 3 {
                    neighbourState = CrucibleState.{neighbour, neighbourDirection, curState.numSteps + 1, neighbourDistance};
                } elseif neighbourDirection != curDirection && neighbourDirection != opposite(curDirection) {
                    neighbourState = CrucibleState.{neighbour, neighbourDirection, 1, neighbourDistance};
                }
                heap.insert(queue, neighbourState);
                // printf("Adding neighbour ({}, {})\n", neighbour.x, neighbour.y);
            }
        }
    }

    canvas.unlock();

    return curState;
}


solve_part_1 :: () -> str {

    printf("Starting to solve part 1\n");
    input := #file_contents "inputs/day17.txt";

    city := string.split(input, '\n');
    startPos := Pos.{0, 0};
    targetPos := Pos.{city[0].length - 1, city.length - 1};

    distances := map.make(CrucibleState, i32);
    visited := set.make(CrucibleState);
    prev := map.make(CrucibleState, CrucibleState);
    queue := heap.make(CrucibleState, (p1: CrucibleState, p2: CrucibleState) => cmp(p1.distance, p2.distance));
    queue << CrucibleState.{startPos, Direction.NORTH, 1}; // Pretend we arrived at 0,0 going north because that will force a "direction change"

    curState: CrucibleState;
    numSteps := 0;
    while !array.empty(queue.data) {
        curState = getShortestPathStep(city, targetPos, &distances, &visited, &prev, &queue);
        // if numSteps % 50000 == 0 {
        //     progress(cast(f64) numSteps / 9333);
        // }
        numSteps += 1;
    }

    return toStr(curState.distance);
}

render :: () {
    // canvas.lock();
    // canvas.clear();

    // posX := lastCrucibleState.pos.x * 5;
    // posY := lastCrucibleState.pos.x * 5;

    // canvas.drawRect(posX, posY, 4, 4, Colour.{255, 0, 0, 255});
    // canvas.unlock();
}


solve_part_2 :: () -> str {
    solve_part_1();
    solve_part_1();
    solve_part_1();
    solve_part_1();
    solve_part_1();
    solve_part_1();
    // Crashes here
    return solve_part_1();
}


exampleInput := """2413432311323
3215453535623
3255245654254
3446585845452
4546657867536
1438598798454
4457876987766
3637877979653
4654967986887
4564679986453
1224686865563
2546548887735
4322674655533""";