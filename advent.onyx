use core {println, printf}

#load "./day1.onyx"
#load "./day2.onyx"
#load "./day3.onyx"
#load "./day4.onyx"
#load "./day5.onyx"

#export "_initialize" _initialize
_initialize :: () {
    use runtime;
    runtime.__runtime_initialize();
    context.thread_id = 0;
}

#export "describe" describe
describe :: (day: i32) -> &str {
    switch day {
        case 1 do return &day1desc;
        case 2 do return &day2desc;
        case 3 do return &day3desc;
        case 4 do return &day4desc;
        case 5 do return &day5desc;
    }
}

progress :: (p: f64) -> void  #foreign "host" "progress" ---


DayPart :: struct {day, part: i32;};
#operator == (d1, d2: DayPart) => d1.day == d2.day && d1.part == d2.part;


#export "solve" solve
solve :: (day: i32, part: i32) -> i32 {

    use runtime.platform


    switch DayPart.{day, part} {
        case .{1, 1} do return solve_day_1_part_1();
        case .{1, 2} do return solve_day_1_part_2();
        case .{2, 1} do return solve_day_2_part_1();
        case .{2, 2} do return solve_day_2_part_2();
        case .{3, 1} do return solve_day_3_part_1();
        case .{3, 2} do return solve_day_3_part_2();
        case .{4, 1} do return solve_day_4_part_1();
        case .{4, 2} do return solve_day_4_part_2();
        case .{5, 1} do return solve_day_5_part_1();
        case .{5, 2} do return solve_day_5_part_2();
    }
}

main :: () {
    println(solve(3, 1));
}